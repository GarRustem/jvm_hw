```
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

# ClassLoader

ClassLoader - это класс, используемый Java для загрузки файлов классов. Java-код компилируется в файл класса при помощи компилятора javac, далее JVM выполняет программу посредством исполнения байт-кода, записанного в файле класса. ClassLoader отвечает за загрузку файлов класса из файловой системы, Сети или иного источника.

Существуют три базовых ClassLoader: Bootstrap, Extension, System (Aplication) class loader.

ClassLoader используется для загрузки классов в runtime и работает по трем принципам:

- **Делегирование**: запрос на загрузку искомого класса к родительскому ClassLoader. Текущий ClassLoader загружает искомый класс **только в случае** если родительские ClassLoader не могут найти или загрузить искомый класс.
- **Видимость**: позволяет ClassLoader-потомкам "видеть" все классы, загруженные ClassLoader-родителями. При этом ClassLoader-родители **не видят** загруженные своими ClassLoader-потомками классы.
- **Уникальность**: гарантирует, что класс будет загружен только один раз, что достигается делегированием - ClassLoader-потомок не станет загружать класс, загруженный ClassLoader-родителем.

Каждый ClassLoader имеет предопределенную область загрузки файлов классов:

1) **Bootstrap** не имеет ClassLoader-родителя, является ClassLoader-родителем всех ClassLoader в Java, и загружает стандартные JDK файлы классов из rt.jar.
2) **Extension ClassLoader** делегирует загрузку искомого класса к  **Bootstrap**, и, если попытка неудачна, пытается загрузить искомый класс из jre/lib/ext или любой другой заданной в настройках директории.
3) **System (Aplication) ClassLoader** является ClassLoader-потомком **Extension ClassLoader**, и в случае, если искомый класс отсутствует в **Extension ClassLoader** и **Bootstrap** - пытается загрузить его из переменных окружения CLASSPATH.

В случае невозможности загрузить искомый файл класса, выбрасывается исключение java.lang.ClassNotFoundException.

После загрузки искомого файла класса происходит его **Связывание**, которое состоит из трех этапов:

1) **Проверка**: гарантирует, что файл класса создан корректным компилятором и отформатирован в соответствии правилам.
2) **Подготовка**: выделение памяти для переменных класса, инициализация памяти для значений по-умолчанию.
3) **Разрешение символьных ссылок**: преобразует символические ссылки из типа в прямые ссылки.

В конечном итоге, если процессы загрузки и связывания успешны, происходит инициализация файла класса.

# Работа JVM

// 1 - При вызове метода **main()** в **Stack Memory** создается фрейм (кадр). В кадрах **Stack Memory** хранятся используемые примитивные типы данных, ссылки на Объекты в **Heap** и указатель на предыдущий метод. Таким образом, объявленный и инициализированный примитивный целочисленный тип данных **i** хранится в текущем кадре **main()** области памяти **Stack Memory**.

// 2 - Ссылочный тип данных Object создается в **Heap**, откуда в кадр для метода **main()** передается ссылка на ячейку памяти в области **Heap**, содержащую значение переменной **о** типа данных Object.

// 3 - Ссылочный тип данных Integer создается в **Heap**, откуда в кадр для метода **main()** передается ссылка на ячейку памяти в области **Heap**, содержащую значение переменной **ii** типа данных Integer.

// 4 - Создается новый кадр в **Stack Memory** - при вызове метода **printAll()**, суть аналогична кадру для метода **main()**. Также в кадр для метода **printAll()** передается ссылка на переменные **o** и **ii**, а переменная **i** типа данных int создается отдельно для кадра метода **printAll()**.

// 5 - Логика работы метода **printAll()**. Ссылочный тип данных Integer создается в **Heap**, откуда в кадр для метода **printAll()** передается ссылка на ячейку памяти в области **Heap**, содержащую значение переменной **uselessVar** типа данных Integer.

// 6 - Логика работы метода **printAll()**. В кадре метода происходит приведение Object о к строковому типу, после чего выполняется конкатенация аргументов метода и вывод их в консоль. Кадр завершает работу: все ссылки на значения переменных ссылочных типов данных и переменные примитивных типов данных удалены, память, занимаемая кадром метода **printAll()** в **Stack Memory**, очищается - "стопка" кадра "снимается" с очереди выполнения и активным становится предыдущий кадр - метод **main()**.

// 7 - В кадре метода **main()** происходит вывод в консоль строки "finished", после чего кадр завершает работу: все ссылки на значения переменных ссылочных типов данных и переменные примитивных типов данных удалены, память, занимаемая кадром метода **main()** в **Stack Memory**, очищается - "стопка" кадра "снимается" с очереди выполнения, программа завершила свою работу.

# Сборщик мусора

Сборка мусора необходима для очистки ограниченного объема памяти от старых неиспользуемых данных. Автоматический процесс без возможности на него влиять.
Сборщик мусора периодически удаляет объекты из памяти **Heap**, если они больше не используются (**Stack Memory** не требует сборщика мусора, так как очищается автоматически по завершении работы кадров (методов/программы).
Мусор - Объект, который больше не может быть достигнут по ссылке из какого-либо Объекта.

### Память в Java состоит из областей:

1) **Heap**: область памяти, в которой JVM хранит Объекты.
2) **Stack Memory**: область памяти для хранения локальных переменных и кадров вызванных методов. Для каждого потока выделяется свой **Stack Memory**.
3) **Metaspace**: область памяти для хранения метаданных классов и статических переменных.
4) **CodeCache**: область работы JIT-компилятора, который компилирует часто исполняемый код, преобразует его в нативный машинный и кеширует для быстрого выполнения.

### Стандартная реализация сборки мусора включает в себя три этапа:

1) **Mark**: Пометка Объектов как живых: сборщик мусора идентифицирует все живые Объекты в памяти путем обхода графа Объектов - если Объект доступен, он живой.
2) **Sweep**: После этапа разметки пространство памяти занято либо живыми (посещенными сборщиком мусора по ссылкам) Объектами, либо мертывыми (не посещенными) Объектами. На данном этапе память освобождается от мертвых Объектов.
3) **Compact**: Для исключения фрагментированного пространства памяти после удаления мертвых Объектов, сборщик мусора располагает оставшиеся Объекты непрерывным блоком в начале **Heap**.

### Для оптимизации сборки мусора память **Heap** состоит из четырех областей, в которые Объекты помещаются в зависимости от их возраста (насколько долго они используются в приложении):

1) **Young Generation**: область **Heap**-памяти, в которой создаются новые Объекты. Разделена на три подраздела:
1.1) **Eden**: все новые Объекты получают здесь начальную область памяти.
1.2) **Survivor Space** - Объекты помещаются сюда после того, как пережили первый цикл сборки мусора. В процессе переполнения объема памяти **Eden** происходит малая сборка мусора, при которой все живые Объекты помещаются в подраздел **S0**, а память **Eden** (и, если это не первый цикл сборки мусора, память **S1**) очищается. При последующих малых сборках мусора все живые Объекты помещаются в подраздел **S1** а память **Eden** и память **S1** очищаются.
1.2.1) **S0**
1.2.2) **S1**
2) **Old Generation**: область **Heap**-памяти, в которой хранятся долгоживущие Объекты.

### Сборка мусора происходит при помощи методов:

1) **Подсчет ссылок**: каждый объект содержит счётчик количества ссылок на него, используемых другими объектами. Когда этот счётчик уменьшается до нуля, это означает, что объект стал недоступным, и он помещается в список объектов на уничтожение. Данный подход испытывает трудности с циклическими ссылками.
2) **Обход графа достижимых объектов** (наиболее частый метод): сборщик мусора может посетить эти Объекты посредством ссылок, начиная от корня (GC Root) - значит они живые, их нужно сохранить. Иначе - помечаются мертвыми, удаляются.
